/*
    MPEI Algebraic Abstractions Library,
    2007-2011,
    Moscow Power Engineering Institute

        This file contains tests of the following classes:

*/
#include <iostream>
#include "./CppUnitLite/TestHarness.h"
#include "./AAF/AAL/Integer.h"
#include "./AAF/AAL/Algorithms.h"
#include "./AAF/AAL/DecompositionManager.h"

using namespace AAL;

/*
	Конструкторы класса Integer
*/
TEST(Integer, EmptyConstructor)
{
	AAL::Integer i;
	CHECK(!i.isPositive() && i.isZero());
}

TEST(Integer, CopyConstructor)
{
	AAL::Integer i("23523523523523523523523523678980767942517895997636"),j(i);
	CHECK(i==j);
}

TEST(Integer, IntConstructor)
{
	AAL::Integer a(-235235234), b(235325235), c(0), d(1), e(-0);

	CHECK(a.isNegative() && a.getDigit(0) == 235235234);
	CHECK(b.isPositive() && b.getDigit(0) == 235325235);
	CHECK(c.isZero());
	CHECK(d.isOne());
	CHECK(e.isZero());
}

TEST(Integer, StringConstructor)
{
	AAL::Integer a("0"), b(""), c("-"), d("-78458745");

	CHECK(a.isZero());
	CHECK(b.isZero());
	CHECK(c.isZero() && !c.isNegative());
	CHECK(d.isNegative() && d.getDigit(0) == 78458745);
}

/* 
	Методы для работы с памятью класса Integer
*/
TEST(Inetger, Relacation)
{
	AAL::Integer i, zero;

	i.Relocation(10);
	CHECK(i.getMaximumDigits() == 10 && i.getNumberDigits() == 0);

	i.setOne();

	try
	{
		i.Relocation(0);
		CHECK(false);
	}
	catch(Exception *E)
	{
		CHECK(true);
	}
}

TEST(Integer, PressMemory)
{
	AAL::Integer i;

	i.Relocation(100);
	CHECK(i.getMaximumDigits() == 100);
	i.PressMemory();
	CHECK(i.getMaximumDigits() == 0);
}

/*
	Методы акцепторы
*/
TEST(Integer, getNumberBits)
{
	AAL::Integer i("1000000000000000000000000000000000000000000000000000000"), j;
	CHECK(i.getNumberBits() == 180);
	CHECK(j.getNumberBits() == 0);
}

TEST(Integer, getNumberBytes)
{
	AAL::Integer i("1000000000000000000000000000000000000000000000000000000"), j, k("123456", Hex);
	CHECK(i.getNumberBytes() == 23);
	CHECK(j.getNumberBytes() == 0);
	CHECK(k.getNumberBytes() == 3);
}

TEST(Integer, getFirstTrueBit)
{
	AAL::Integer i("100000111111110101010101010000010000100000", Bin);
	CHECK(i.getFirstTrueBit() == 5);
}

TEST(Integer, getBit)
{
	AAL::Integer i("100000111111110101010101010000010000100000", Bin);
	CHECK(i.getBit(35));
}

TEST(Integer, setBit)
{
	AAL::Integer i("11110101010101010101010101010101101111111111111111111111111100010101001000000001", Bin);
	i.setBit(37, false);
	CHECK(!i.getBit(37) && i.ToString(Bin) == "11110101010101010101010101010101101111111101111111111111111100010101001000000001");
}

TEST(Integer, getDigit)
{
	AAL::Integer i("100000111111110101010101010000010000100000", Bin);
	CHECK(i.getDigit(1) == 527);
}

TEST(Integer, setDigit)
{
	AAL::Integer i("32512122FFFFFFFF", Hex);
	i.setDigit(2, -1);
	CHECK(i.getDigit(2) == -1 && i.ToString(Hex) == "ffffffff32512122ffffffff");
}

TEST(Integer, isPrime)
{
	AAL::Integer two(2), one(1), prime(4567), zero;
	AAL::Integer n_two(-2), n_one(-1), n_prime(-4567);
	AAL::Integer i("6090704078294453851176802772200892611268597745607505204705821932151560269950977984707771728002625121"), j("59939809699859779597247525822363827189176265589868765949574673145565288845560162916419813029255470970518213"), k("306238661813108381785247757872756553256233886436075926170559");
	AAL::Integer n_i("-6090704078294453851176802772200892611268597745607505204705821932151560269950977984707771728002625121"), n_j("-59939809699859779597247525822363827189176265589868765949574673145565288845560162916419813029255470970518213"), n_k("-306238661813108381785247757872756553256233886436075926170559");

	CHECK(two.isPrime() && n_two.isPrime());
	CHECK(!one.isPrime() && !n_one.isPrime());
	CHECK(prime.isPrime() && n_prime.isPrime());
	CHECK(i.isPrime() && n_i.isPrime());
	CHECK(j.isPrime() && n_j.isPrime());
	CHECK(k.isPrime() && n_k.isPrime());
	CHECK(!zero.isPrime());
}

/*Функция Эйлера*/
TEST(Integer,Euler)
{
  AAL::Integer a(8);
  std::vector<DecompositionMember> vector(DecompositionManager::Instance().getPrimeDecomposition(8));
  a.Euler(vector);
  CHECK(a == 4);

}

/*
	Унарные операторы
*/
TEST(Integer, unaryOperatorSub)
{
	AAL::Integer i(10);
	AAL::Integer j = -i;

	CHECK(i == 10);
	CHECK(j == -10);
}

TEST(Integer, Negate)
{
	AAL::Integer i(100);
	i.Negate();
	CHECK(i == -100);
}

TEST(Integer, unaryOperatorOnesComplement)
{
	AAL::Integer i(1000);
	AAL::Integer j, jj("-4294966295");
	j = ~i;

	CHECK(i == 1000);
	CHECK(j == jj);
}

TEST(Integer, OnesComplement)
{
	AAL::Integer i("-FFFFFFFFFFFFFFFFFFFFFFFA", Hex);
	i.OnesComplement();

	CHECK(i == 5 && i.getNumberDigits() == 1);
}

TEST(Integer, Increment)
{
	AAL::Integer i(24);
	++(i++)++;

	CHECK(i == 27);
}

TEST(Integer, Decrement)
{
	AAL::Integer i(14314);
	--(i--)--;

	CHECK(i == 14311);
}

TEST(Integer, operatorEqual)
{
	AAL::Integer i1("2352352352356236236236");
	AAL::Integer i2("92386598236589236589236589236589236589236589");
	AAL::Integer i3("2352352525");
	AAL::Integer ii1, ii2, ii3, ii4;

	ii1 = i1;
	ii2 = ii3 = i2;

	i2 = i1;
	i3 = ii4;

	CHECK(ii1 == i1 && !ii1.isZero() && ii1.ToString() == "2352352352356236236236");
	CHECK(ii2 == ii3 && !ii3.isZero() && ii2.ToString() == "92386598236589236589236589236589236589236589");
	CHECK(i2 == i1 && i2.getNumberDigits() == 3 && i2.ToString() == "2352352352356236236236");
	CHECK(i3.isZero());
}

/*
	Операции сравнения
*/
TEST(Integer, Compare)
{
	AAL::Integer i("23989382568932658932658923658923568293562"), j("0937459023759023759023759023759032759032759072350957902375039275093257"), comp("-937459023759023759023759023735043376463826413418298978716115706799695");
	CHECK(i.Compare(j) ==  comp);
}

TEST(Integer, Equal)
{
	AAL::Integer i,j;
	i.Negate();
	CHECK(i == j && !i.isNegative());

	AAL::Integer k("2354235235235235235235235325235235235235235235"), l("23453456346346346");
	CHECK(!(k == l) && !(k == j));

	AAL::Integer m("2352365236236"), n("2352365236236");
	CHECK(m == n);

	AAL::Integer *o = new AAL::Integer("123456789"), *p = o;
	CHECK(*o == *p);
	delete o;

	AAL::Integer r("-3463467346346346346346346346346346346346436"), s("-98231469826489126489125647892514785123478125478215478125478125478125478125478"), w("3463467346346346346346346346346346346346436");
	CHECK(!(r == s) && !(r == k));
}

TEST(Integer, Smaller)
{
	AAL::Integer i("325235623623623623623632623623"), j(231453532);
	CHECK(j < i);

	AAL::Integer k,l("-");
	CHECK(!(l < k) && l == k);

	AAL::Integer m("23525235235235235"), n("-2345623562363262362362626262626"), r("-239423961279217894612786478124681725478215478124578"), s("23525235235235235");
	CHECK(n<m && r<m && r<n && !(m<s) && m==s);
}

/*
	Логические операции
*/
TEST(Integer, Xor)
{
	AAL::Integer i("100000101010101010100001111100011111111111111111111111111100000000000000000000000000000000", Bin);
	AAL::Integer j("001010101111111110100101010100101010101010101001010010100100000000000000001111111111111111", Bin);
	AAL::Integer res;
	AAL::Integer iXORj("101010000101010100000100101000110101010101010110101101011000000000000000001111111111111111", Bin);
	
	res.Xor(i, j);
	CHECK(res == iXORj);

	res.Xor(i,i);
	CHECK(res.isZero());

	res.Xor(j, iXORj);
	CHECK(res == i);
}

TEST(Integer, Or)
{
	AAL::Integer i("100000101010101010100001111100011111111111111111111111111100000000000000000000000000000000", Bin);
	AAL::Integer j("001010101111111110100101010100101010101010101001010010100100000000000000001111111111111111", Bin);
	AAL::Integer k;
	AAL::Integer res;
	AAL::Integer iORj("101010101111111110100101111100111111111111111111111111111100000000000000001111111111111111", Bin);
	
	res.Or(i, j);
	CHECK(res == iORj);

	res.Or(i, k);
	CHECK(res == i);

	res.Or(i,i);
	CHECK(res == i);
}

TEST(Integer, And)
{
	AAL::Integer i("100000101010101010100001111100011111111111111111111111111100000000000000000000000000000000", Bin);
	AAL::Integer ii("100000101010101010100001111100011111111111111111111111111100000000000000000000000000000000", Bin);
	AAL::Integer j("001010101111111110100101010100101010101010101001010010100100000000000000001111111111111111", Bin);
	AAL::Integer k;
	AAL::Integer res;
	AAL::Integer iANDj("000000101010101010100001010100001010101010101001010010100100000000000000000000000000000000", Bin);
	
	res.And(i, j);
	CHECK(res == iANDj);

	res.And(i, k);
	CHECK(res.isZero());

	res.And(i,i);
	CHECK(res == i);
}

TEST(Integer, Not)
{
	AAL::Integer i("100000101010101010100001111100011111111111111111111111111100000000000000000000000000000000", Bin);
	AAL::Integer k;
	AAL::Integer res;
	AAL::Integer NOTi("011111010101010101011110000011100000000000000000000000000011111111111111111111111111111111", Bin);
	
	res.Not(i);
	CHECK(res == NOTi);

	CHECK((!k).isOne() && k.isZero());
}

/*
	Операции побитового сдвига
*/
TEST(Integer, SHL)
{
	AAL::Integer i("100000001010101001010101010001010100010100101111111111111111111111111100000111111111111111111111000001111111111111000001111111111111", Bin);
	AAL::Integer j("100000001010101001010101010001010100010100101111111111111111111111111100000111111111111111111111000001111111111111000001111111111111000000000000000000000000000000000000000000000", Bin);
	AAL::Integer k;

	k<<=100;
	CHECK((i<<45) == j && k.isZero());
}

TEST(Integer, SHR)
{
	AAL::Integer i("100000001010101001010101010001010100010100101111111111111111111111111100000111111111111111111111000001111111111111000001111111111111", Bin);
	AAL::Integer j("10000000101010100101010101000101010001010010111111111111111111111111110000011111111111111111111", Bin);
	AAL::Integer k;

	k>>=10001;
	CHECK((i>>37) == j && k.isZero());
}

/*
	Операция сложения
*/
TEST(Integer, Add)
{
	AAL::Integer i("93824598236548923659823658923658923658923658932589238596"), j("923645892359023750923759023759032759023750923759072350"), k("-02395092375923589236589236589236589236598236589236598235");
	AAL::Integer l(-1);
	AAL::Integer zero;

	AAL::Integer iADDj("94748244128907947410747417947417956417947409856348310946");
	AAL::Integer jADDk("-1471446483564565485665477565477556477574485665477525885");

	CHECK((i+j) == iADDj && i.ToString()=="93824598236548923659823658923658923658923658932589238596" && j.ToString() == "923645892359023750923759023759032759023750923759072350");
	CHECK(i.Add(i, j) == iADDj && j.ToString() == "923645892359023750923759023759032759023750923759072350" && i.ToString() != "93824598236548923659823658923658923658923658932589238596");
	CHECK(j.Add(j, zero).ToString() == "923645892359023750923759023759032759023750923759072350" && !j.isZero() && zero.isZero());
	CHECK((j + k) == jADDk && j.ToString() == "923645892359023750923759023759032759023750923759072350" && k.ToString() == "-2395092375923589236589236589236589236598236589236598235");
	CHECK(l.Add(l,l) == -2);
}

/*
	Операция вычитания
*/
TEST(Integer, Sub)
{
	AAL::Integer i("93824598236548923659823658923658923658923658932589238596"), j("923645892359023750923759023759032759023750923759072350"), k("-02395092375923589236589236589236589236598236589236598235");
	AAL::Integer l(-1);
	AAL::Integer m(1);
	AAL::Integer zero;

	AAL::Integer iSUBj("92900952344189899908899899899899890899899908008830166246");
	AAL::Integer jSUBk("3318738268282612987512995612995621995621987512995670585");
	AAL::Integer kSUBi("-96219690612472512896412895512895512895521895521825836831");

	CHECK((i-j) == iSUBj && i.ToString()=="93824598236548923659823658923658923658923658932589238596" && j.ToString()=="923645892359023750923759023759032759023750923759072350");
	CHECK((k-i) == kSUBi && i.ToString()=="93824598236548923659823658923658923658923658932589238596" && k.ToString()=="-2395092375923589236589236589236589236598236589236598235");
	CHECK(i.Sub(i, j) == iSUBj && j.ToString()=="923645892359023750923759023759032759023750923759072350" && i.ToString() != "93824598236548923659823658923658923658923658932589238596");
	CHECK(j.Sub(j, zero).ToString() == "923645892359023750923759023759032759023750923759072350" && !j.isZero() && zero.isZero() && j.Sub(zero, j).Negate().ToString() == "923645892359023750923759023759032759023750923759072350");
	CHECK((j-k) == jSUBk && j.ToString()=="923645892359023750923759023759032759023750923759072350" && k.ToString()=="-2395092375923589236589236589236589236598236589236598235");
	CHECK(l.Sub(l,m) == -2);
	CHECK(m.Sub(m, m) == 0 && m.isZero());
}

/*
	Операция умножения
*/
TEST(Integer, Mul)
{
	AAL::Integer i("0293759802375890237590237590237590237590375092375902375092375092750"), j("09459023476902375902374690723459723496723962397927"), k("-93852938568239658923658923647289"), n("-9381269182648912648912645891264589126458912654891265891658912659");
	AAL::Integer zero;

	AAL::Integer iMULj("2778680867243748100515629803549127141357239872889104409756269935425948082821740518073691977974684724281019032729250");
	AAL::Integer iMULk("-27570220686202649070919156889008420992227742206508537402338117206076742711848955652658489661054750");
	AAL::Integer kMULn("880459680291268275225264975629783490391681446284299799431978302040268173070249179709012173131451");
	AAL::Integer nMULn("88008211477318197594529469045517652788689167877329524528149438806138802337073377846963103227426383099826330609663794230190450281");

	CHECK((i*j)==iMULj && i.ToString()=="293759802375890237590237590237590237590375092375902375092375092750" && j.ToString()=="9459023476902375902374690723459723496723962397927");
	CHECK(i*k == iMULk  && i.ToString()=="293759802375890237590237590237590237590375092375902375092375092750" && k.ToString()=="-93852938568239658923658923647289");
	CHECK(k.Mul(k,n) == kMULn && n.ToString()=="-9381269182648912648912645891264589126458912654891265891658912659" && k.ToString()!="-93852938568239658923658923647289");
	CHECK(i.Mul(zero, zero) == 0 && i.isZero() && zero.isZero());
	CHECK(j.Mul(n,zero) == 0 && n.ToString()=="-9381269182648912648912645891264589126458912654891265891658912659" && zero.isZero() && j.isZero());
	CHECK(j.Mul(n, n) == nMULn && n.ToString()=="-9381269182648912648912645891264589126458912654891265891658912659");
}
TEST(Integer, ModMul)
{
	AAL::Integer i("3"),j("39959873133239853064831683881575884792784177059912510633049782097043525897040108610946542019503647313678809"),k("59939809699859779597247525822363827189176265589868765949574673145565288845560162916419813029255470970518213");
	AAL::Integer res;
	CHECK(res.ModMul(i,j,k).isOne())
}

/*
	Операция деление
*/
TEST(Integer, Div)
{
	AAL::Integer i("293759802375890237590237590237590237590375092375902375092375092750"), j("9459023476902375902374690723459723496723962397927"), k("-93852938568239658923658923647289"), n("-9381269182648912648912645891264589126458912654891265891658912659");
	AAL::Integer ii("119879619399719559194495051644727654378352531179737531899149346291130577691120325832839626058510941941036427"), jj("59939809699859779597247525822363827189176265589868765949574673145565288845560162916419813029255470970518213"), two(2);
	AAL::Integer iii("599398096998597795972475258223638271891762655898687659495746731455652888455601629164198130292554709705182131"), ten(10);
	AAL::Integer zero, rem;

	AAL::Integer iDIVj("31056039039675813");
	AAL::Integer iDIVk("-3130001115120119857129124638558074");
	AAL::Integer nDIVk("99957117227905155705787589163786");
	AAL::Integer nREMk("-57417428080224270675726943036505");

	CHECK((i/j)==iDIVj && i.ToString()=="293759802375890237590237590237590237590375092375902375092375092750" && j.ToString()=="9459023476902375902374690723459723496723962397927");
	CHECK(i/k == iDIVk  && i.ToString()=="293759802375890237590237590237590237590375092375902375092375092750" && k.ToString()=="-93852938568239658923658923647289");
	CHECK(n.Div(n, k, &rem) == nDIVk && k.ToString()=="-93852938568239658923658923647289" && rem==nREMk);
	CHECK(i.Div(zero, i).isZero() && i.isZero() && zero.isZero());

	try
	{
		j.Div(n,zero);
		CHECK(false);
	}
	catch(Exception *E)
	{
		CHECK(true);
	}
	CHECK((ii/jj) == two);
	CHECK((iii/jj) == ten);

        AAL::Integer a("7907625915930255974616902488834428871568732510467665372595074207598007568853403914143558249060018496471634647195684070532840151603837158775762029726478655997560696112152198415517106805815588973853636194362645200040249434125776128536340811629524848704378024655888530796689097233146870422627311101523758131239860255062820510282741319901148431534999213215363534121237188194950246284442249548595555781122453612549517085054531233995922889749586673144014476787252150592743022654922687150869291812896325927934503293681102586066710347304382079042809556573966434559044700575973228231117989078950519716287995538203121342643929691810875645314924865979433114835616422571549164410495752130127239756399127685954763999852995652000715806933369288408707753549095114261820007947701632817349789046076530277096838749081825347635066364802515029585174421701561060380414675119918760178110966120396548278013577977522799979878007655471804453493745898233953698239585008558258080513959919616");
        AAL::Integer module("7907625915930255974616902488834428871568732510467665372595074207598007568853403914143558249060018496471634647195684070532840151603837158775762029726478655997560696112152198415517106805815588973853636194362645200040249434125776128536340811629524848704378024655888530796689097233146870422627311101523758131239860255062820510282741319901148431534999213215363534121237188194950246284442249548595555781122453612549517085054531233995922889749586673144014476787252150592743022654922687150869291812896325927934503293681102586066710347304382079042809556573966434559044700575973228231117989078950519716287995538203121342643929691810875645314924865979433114835616422571549164410495752130127239756399127685954763999852995652000715806933369288408707753549095114261820007947701632817349789046076530277096838749081825347635066364802515029585174421701561060380414675119918760178110966120396548278013577977522799979878007655471804453493745898233953698239585008558258080513959919617");
        AAL::Integer remainder;
        a.Mul(a,a);
        a.Div(a, module, &remainder);
        CHECK(remainder.isOne());
}

TEST(Integer, Div1)
{
	AAL::Integer i("-4"), j("4");
	AAL::Integer iDIVj("-1");

	CHECK((i/j)==iDIVj);
}

/*
	Операция приведения по модулю
*/
TEST(Integer, Mod)
{
	AAL::Integer i("293759802375890237590237590237590237590375092375902375092375092750"), j("9459023476902375902374690723459723496723962397927"), k("-93852938568239658923658923647289"), n("-9381269182648912648912645891264589126458912654891265891658912659");
	AAL::Integer zero;

	AAL::Integer iMODj("5741240516958562364670076641423621899220191853099");
	AAL::Integer iMODk("47943561111692641513130455931364");
	AAL::Integer nMODk("-57417428080224270675726943036505");

	CHECK((i%j)==iMODj && i.ToString()=="293759802375890237590237590237590237590375092375902375092375092750" && j.ToString()=="9459023476902375902374690723459723496723962397927");
	CHECK(i%k == iMODk  && i.ToString()=="293759802375890237590237590237590237590375092375902375092375092750" && k.ToString()=="-93852938568239658923658923647289");
	std::string str = n.Mod(n, k).ToString();
	CHECK(n.Mod(n, k) == nMODk && k.ToString()=="-93852938568239658923658923647289");

        try
        {
        	CHECK(i.Mod(zero, zero).isZero() && zero.isZero());
        }
        catch(Exception *E)
        {
                CHECK(true);
        }

        AAL::Integer a("7907625915930255974616902488834428871568732510467665372595074207598007568853403914143558249060018496471634647195684070532840151603837158775762029726478655997560696112152198415517106805815588973853636194362645200040249434125776128536340811629524848704378024655888530796689097233146870422627311101523758131239860255062820510282741319901148431534999213215363534121237188194950246284442249548595555781122453612549517085054531233995922889749586673144014476787252150592743022654922687150869291812896325927934503293681102586066710347304382079042809556573966434559044700575973228231117989078950519716287995538203121342643929691810875645314924865979433114835616422571549164410495752130127239756399127685954763999852995652000715806933369288408707753549095114261820007947701632817349789046076530277096838749081825347635066364802515029585174421701561060380414675119918760178110966120396548278013577977522799979878007655471804453493745898233953698239585008558258080513959919616");
        AAL::Integer module("7907625915930255974616902488834428871568732510467665372595074207598007568853403914143558249060018496471634647195684070532840151603837158775762029726478655997560696112152198415517106805815588973853636194362645200040249434125776128536340811629524848704378024655888530796689097233146870422627311101523758131239860255062820510282741319901148431534999213215363534121237188194950246284442249548595555781122453612549517085054531233995922889749586673144014476787252150592743022654922687150869291812896325927934503293681102586066710347304382079042809556573966434559044700575973228231117989078950519716287995538203121342643929691810875645314924865979433114835616422571549164410495752130127239756399127685954763999852995652000715806933369288408707753549095114261820007947701632817349789046076530277096838749081825347635066364802515029585174421701561060380414675119918760178110966120396548278013577977522799979878007655471804453493745898233953698239585008558258080513959919617");
        a.Mul(a,a);
        CHECK(a.Mod(a, module).isOne());
}

/*
	Операция возведение в степень
*/
TEST(Integer, Pow)
{
	AAL::Integer i("9235293859823589236589235"), j("124"), k("-1246129864912864892164891265"), n("12");
	AAL::Integer zero;
	AAL::Integer res;

	CHECK(res.Pow(i,n).ToString() == "384953814037412955498058344441050937881305395182795483408124738487375640021561904949297555591120437663719508664336501501498069258456096162954108023728970699146511356532653996896555302193643113432092746881519726231883930787792546785726373055550833772473025951943713238702436547817644096645273681640625" && i.ToString() == "9235293859823589236589235" && n.ToString() == "12");
	CHECK(res.Pow(j,j).ToString() == "38396263207766492998686092737671915638804430563359415737788423279490969529831292627384794273039541127905585733228895877947791412155596317229225620394566830825684140767703850232233381444765476298064410074919530461929162865000250444792787196227133278081175781376" && j.ToString() == "124");
    try
	{
        CHECK(k.Pow(k, k).isZero());
        CHECK(false);
	}
	catch(Exception *E)
	{
		CHECK(true);
	}
	CHECK(res.Pow(i, zero).isOne() && i.ToString() == "9235293859823589236589235");
}

TEST(Integer, ModPow)
{
	AAL::Integer i("64589126548916245"), j("912364982164981264589126458912658912698");
	CHECK(i.ModPow(i,j,j).ToString() == "559438084656362219981850988161047408147" && j.ToString()=="912364982164981264589126458912658912698");
	CHECK(j.ModPow(i,j,j).ToString() == "254886536772384783386157251155707616157" && i.ToString() == "559438084656362219981850988161047408147");
}

/*
	Операция извлечения квадратного корня
*/
TEST(Integer, Sqrt)
{
	AAL::Integer i(219846), j("1298641251154235"), k("02375092375902375902359023759027359027359023590237095239056"), zero;

	CHECK(i.Sqrt(i).ToString() == "468");
	CHECK(j.Sqrt().ToString() == "36036665");
	CHECK(k.Sqrt(k).ToString() == "48734919471590141351848377328");
	CHECK(zero.Sqrt().isZero());
}
TEST(Integer, SquareRoot) {
 AAL::Integer i("4");
 AAL::Integer j;
 AAL::Integer rez("2");
 AAL::Integer elevenDigits("68719476735");
 AAL::Integer result(262143);
 CHECK(j.SquareRoot(i) == rez);
 CHECK(j.SquareRoot(elevenDigits) == result);

}
/*
	Алгоритмы Евклида
*/
TEST(Integer, Euclid)
{
	AAL::Integer i("98124912648901264590812659012569"), j("91236498126491264890126589126589125"), k("-9218649281648921648912645892156981256"), n("-9812498214981246891248912892165928156");
	AAL::Integer m("19337611067939547873225564092064710678452296377412042637058926912172734134795250022378125"), l("4361531449329236910159518875");
	AAL::Integer zero,res;

	CHECK(res.Euclid(i, j).ToString() == "1");
	CHECK(i.Euclid(i,i).ToString() == "98124912648901264590812659012569");
	CHECK(i.Euclid(i,k).ToString() == "1");
	CHECK(res.Euclid(zero, n).ToString() == "9812498214981246891248912892165928156");
	CHECK(res.Euclid(k, n).ToString() == "4");
	try
	{
		zero.Euclid(zero, zero).isZero();
		CHECK(false);
	}
	catch(Exception *E)
	{
		CHECK(true);
	}
	CHECK(res.Euclid(m, l).ToString() == "12351235125125125");
}

TEST(Integer, BinaryGCD)
{
	AAL::Integer i("98124912648901264590812659012569"), j("91236498126491264890126589126589125"), k("-9218649281648921648912645892156981256"), n("-9812498214981246891248912892165928156");
	AAL::Integer m("19337611067939547873225564092064710678452296377412042637058926912172734134795250022378125"), l("4361531449329236910159518875");
	AAL::Integer zero,res;

	CHECK(res.BinaryGCD(i, j).ToString() == "1");
	CHECK(i.BinaryGCD(i,i).ToString() == "98124912648901264590812659012569");
	CHECK(i.BinaryGCD(i,k).ToString() == "1");
	CHECK(res.BinaryGCD(zero, n).ToString() == "9812498214981246891248912892165928156");
	CHECK(res.BinaryGCD(k, n).ToString() == "4");
 	try
	{
		zero.BinaryGCD(zero, zero).isZero();
		CHECK(false);
	}
	catch(Exception *E)
	{
		CHECK(true);
	}
	CHECK(res.BinaryGCD(m, l).ToString() == "12351235125125125");
}

TEST(Integer, ExEuclid)
{
	AAL::Integer i("98124912648901264590812659012569"), j("91236498126491264890126589126589125"), k("-9218649281648921648912645892156981256"), n("-9812498214981246891248912892165928156");
	AAL::Integer m("19337611067939547873225564092064710678452296377412042637058926912172734134795250022378125"), l("4361531449329236910159518875");
	AAL::Integer zero,res,x,y;

	CHECK(res.ExEuclid(i, j, x, y).ToString() == "1" && x.ToString() == "-13426502622787877062383385061419471" && y.ToString() == "14440212240662102690185084489496");
	CHECK(i.ExEuclid(i,i,x,y).ToString() == "98124912648901264590812659012569" && y.isZero() && x.isOne());
	CHECK(i.ExEuclid(i,k,x,y).ToString() == "1" && x.ToString() == "-1172920693373479052195884358092737151" && y.ToString() == "-12484772667344051990272857807445");
	CHECK(res.ExEuclid(zero,n,x,y).ToString() == "9812498214981246891248912892165928156" && x.isZero() && y.Negate().isOne());
	CHECK(res.ExEuclid(k, n, k, n).ToString() == "4" && k.ToString() == "349856830839043512745399229619126138" && n.ToString() == "-328683618751667779711964468610378547");
   	try
	{
		zero.ExEuclid(zero,zero,x,y);
		CHECK(false);
	}
	catch(Exception *E)
	{
		CHECK(true);
	}
	try
	{
		i.ExEuclid(k, n, i, j);
		CHECK(false);
	}
	catch(Exception *E)
	{
		CHECK(true);
	}
	CHECK(res.ExEuclid(m,l,x,y).ToString() == "12351235125125125" && x.ToString() == "-169814379975" && y.ToString() == "752901697912752776805434164816822274550859960655696689878465706748202976");
}
TEST(Integer, SCM)
{ AAL::Integer a("5");
  AAL::Integer b("2");
  AAL::Integer result("10");
  AAL::Integer rez;
  rez.SCM(a,b);
  CHECK(rez == result);
}
/*
	Генерация чисел
*/
TEST(Integer, GenerateOdd)
{
	AAL::Integer i, j, module("210490125907590127590123759012375901275");

	CHECK(i.GenerateOdd(112).isOdd() && i.getNumberBits() == 112);
	CHECK(j.GenerateOdd(module).isOdd() && j<module);
}
TEST(Integer, WrappingGenerate)
{
    AAL::Integer forwrap("555"), badforwrap("5656565655656565656566566656565656565656656"), module("95895441303634293975547"), result;
    result.WrappingGenerate(forwrap, module);
	CHECK(result.ToString()[result.ToString().length() - 3] == '5' && result.ToString()[result.ToString().length() - 2] == '5' && result.ToString()[result.ToString().length() - 1] == '5');
  //  std::cout<<result.ToString().c_str();
    try
    {
        result.WrappingGenerate(badforwrap, module);
        CHECK(false);
    }
    catch(Exception *E)
    {
        CHECK(true);
    }
}

/*
	Вычисление символов Якоби и Лежандра
*/
TEST(Integer, LegandreSymbol)
{
	AAL::Integer i("23450923750923759023757902357235"), j("2356232362363256236236236712"), module("72370055773322622139731865630429942408293740416025352524661566465698076557313");
	CHECK(i.LegendreSymbol(module) == -1);
	CHECK(j.LegendreSymbol(module) == 1);
	CHECK(module.LegendreSymbol(module) == 0);
}

TEST(Integer, JacobySymbol)
{
	AAL::Integer i("2345702397539257932"), j("3029438925783253829583295");
	CHECK(i.JacobySymbol(j) == -1);
}

/*
	Операции мультипликативной группы и поля
*/
TEST(Integer, Inverse)
{
	AAL::Integer i("327372592375893275892375893275892375892375"), module("72370055773322622139731865630429942408293740416025352524661566465698076557313");
	AAL::Integer inverse_i("44430819574512914473561118663292938632950978604733664933196082356432308111625");
	CHECK(i.Inverse(module) == inverse_i);
}

TEST(Integer, Inverse1)
{
	AAL::Integer i("4"), module("5"), notprimemodule(6), i_for_notprimemodule(2);
	AAL::Integer inverse_i("4");
	CHECK(i.Inverse(module) == inverse_i);
        try
        {
                i_for_notprimemodule.Inverse(notprimemodule);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }
}

TEST(Integer, ModSqrt)
{
	AAL::Integer i("2356232362363256236236236712"), i_module("72370055773322622139731865630429942408293740416025352524661566465698076557313");
        AAL::Integer i_modsqrt1("18627647720334103070131956925579522241195421092572607745123819351711819426187"), i_modsqrt2;
        i_modsqrt2.Sub(i_module, i_modsqrt1);

        i.ModSqrt(i_module);
	CHECK(i == i_modsqrt1 || i == i_modsqrt2);

        AAL::Integer a("2"), a_module("9149585060559937601537");
        AAL::Integer a_modsqrt1("5859699500935051688665"), a_modsqrt2("3289885559624885912872");

        a.ModSqrt(a_module);
	CHECK(a == a_modsqrt1 || a == a_modsqrt2);
}
TEST(Integer, elementOrder)
{ AAL::Integer grMod(15);
  AAL::Integer num(7);
  AAL::Integer a;
  AAL::Integer rez;
  std::vector<DecompositionMember> vector(DecompositionManager::Instance().getPrimeDecomposition(15));
  a.Euler(vector);
  std::vector<DecompositionMember> vector1(DecompositionManager::Instance().getPrimeDecomposition(8));
  rez.elementOrder(grMod,num,vector1,AAL::Integer(8));
CHECK(rez == 4);
}
TEST(Integer, isGenerator)
{ AAL::Integer grMod(15);
  AAL::Integer num(7);
  AAL::Integer a;
  AAL::Integer rez;
  AAL::Integer const_8(8);

  std::vector<DecompositionMember> vector(DecompositionManager::Instance().getPrimeDecomposition(15));
  a.Euler(vector);
  std::vector<DecompositionMember> vector1(DecompositionManager::Instance().getPrimeDecomposition(8));
  bool r = rez.isGenerator(grMod,num,vector1,const_8);
CHECK(r == false);
}
/*
	Тесты для парсинга и перевода в строку
*/
TEST(Integer, SimpleParse)
{
	AAL::Integer a,b,c,d,e;
	std::string hexNumber = "ababf98234f5f9f0f8f2f3f65f9f0f2f3f75a9a0a32a7a5a9ac2c0c3c5c7c9c0c23c5c7c34634764367436436346346346436346346";
	std::string decNumber = "464833135264483657268392702305618602710357582818544649603488732117126373452405861590191015088422093330847562441596318164777722694";
	std::string octNumber = "25352774602151727717417436274773137476074571767265150121452364552326054030361343711601410742707606430643544154720662066150615061506206615061506";
	std::string binNumber = "10101011101010111111100110000010001101001111010111111001111100001111100011110010111100111111011001011111100111110000111100101111001111110111010110101001101000001010001100101010011110100101101010011010110000101100000011000011110001011100011111001001110000001100001000111100010111000111110000110100011000110100011101100100001101100111010000110110010000110110001101000110001101000110001101000110010000110110001101000110001101000110";
        std::string ternNumber = "200212122222122210212102021010001101111212011022222000202202110202002212211111022102000001112121120111122020111120022220121011201000011100012020021212110011020021201212202200202110000010201002220011212202022010210122101001002020022102212101201010020111210021101121001012";

	a.Parse(hexNumber, Hex);
	b.Parse(decNumber, Dec);
	c.Parse(octNumber, Oct);
	d.Parse(binNumber, Bin);
        e.Parse(ternNumber, Tern);

	CHECK(a==b && a==c && a==d && a==e);
}

TEST(Integer, NegativeParse)
{
  AAL::Integer mod(100);
  for( int i=0; i<100; i++ ) {
    AAL::Integer x;
    x.GenerateOdd(mod);
    std::string s = x.ToString( Dec );
  }


	AAL::Integer a,b,c,d,e;
	std::string hexNumber = "-928164912642891469812649acdababf98234f5f9f0f8f2f3f65f9faffffffffffffff0f2f3f75a9a0a32a7a5a9ac2c0c3c5c7c9c0c23c5c7c34634764cdeeeeeeebbbb36bbbb7b4b3b64b3b6b3b46b3b4b63b4b6b4b36346346";
	std::string decNumber = "-3156535414053327452312266685358778094683706038785631120798387038911455479251318200952876927167039618765681003356343581297803187224754517379255600219286777123003744291437601504365711225459892225667067556394586632119110";
	std::string octNumber = "-445005444422310242212151402231115315527257714043236576370370745717662771765777777777777777777417136375655232024312475132465413006074270762340302170561741506150731146756735673535673155356733664547331131666547321531664554355133264546615061506";
	std::string binNumber = "-100100101000000101100100100100010010011001000010100010010001010001101001100000010010011001001001101011001101101010111010101111111001100000100011010011110101111110011111000011111000111100101111001111110110010111111001111110101111111111111111111111111111111111111111111111111111111100001111001011110011111101110101101010011010000010100011001010100111101001011010100110101100001011000000110000111100010111000111110010011100000011000010001111000101110001111100001101000110001101000111011001001100110111101110111011101110111011101011101110111011001101101011101110111011011110110100101100111011011001001011001110110110101100111011010001101011001110110100101101100011101101001011011010110100101100110110001101000110001101000110";
        std::string ternNumber = "-2022022201020002102010002022112010000210121100021120102200020112201220010110020022022010010101110100100202000011101222000010202020001110121111122201221200220010001201202122010022010221211102121212101102102202221110000011111022100021002001112112110110220201001022022200121212011100001210012001212221002212210221002212120101222221020021110001102020221111102211111221000211002211222121112221222022221221201112201001100212112100200100210012001010212110110112";

	a.Parse(hexNumber, Hex);
	b.Parse(decNumber, Dec);
	c.Parse(octNumber, Oct);
	d.Parse(binNumber, Bin);
        e.Parse(ternNumber, Tern);

	CHECK(a==b && a==c && a==d && a==e);
}

TEST(Integer, NullParse)
{
	AAL::Integer a(1),b(2),c;
	std::string nullString1 = "0";
	std::string nullString2 = "-0";

	a.Parse(nullString1);
	b.Parse(nullString2);

	CHECK(a==b && a==c);
}

TEST(Integer, EmptyParse)
{
	AAL::Integer a(1),b(2),c;
	std::string emptyString1 = "";
	std::string emptyString2 = "-";

	a.Parse(emptyString1);
	b.Parse(emptyString2);
	CHECK(a==b && a==c);
}

TEST(Integer, ErrorStringParse)
{
	AAL::Integer a;
	std::string hexNumber = "ababf023975jflsdnfdklhg9w34y50923754-02q3rwajf;oasjf98234f5f9f0f8f2f3f65f9f0f2f3f75a9a0a32a7a5a9ac2c0c3c5c7c9c0c23c5c7c34634764367436436346346346436346346";
	try
	{
		a.Parse(hexNumber, Hex);
		CHECK(false);
	}
	catch(Exception *E)
	{
		CHECK(true);
	}
}

TEST(Integer, SimpleToString)
{
	std::string str1("2352356389252389658923648912642891642891648129648912658912658965");
	std::string str2("10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

	AAL::Integer a(str1), b(str2);

	CHECK(a.ToString() == str1);
	CHECK(b.ToString() == str2);
}

TEST(Integer, ToString)
{
	std::string ternNumber = "200212122222122210212102021010001101111212011022222000202202110202002212211111022102000001112121120111122020111120022220121011201000011100012020021212110011020021201212202200202110000010201002220011212202022010210122101001002020022102212101201010020111210021101121001012";
	AAL::Integer c(ternNumber, Tern);

	CHECK(c.ToString(Tern) == ternNumber);
}

TEST(Integer, isGeneratorInFp)
{
        AAL::Integer module("13"), four("4"), seven("7");
        std::vector<DecompositionMember> decomposition;

        decomposition.push_back(DecompositionMember(AAL::Integer("2"), AAL::Integer("2")));
        decomposition.push_back(DecompositionMember(AAL::Integer("3"), AAL::Integer("1")));

        CHECK(seven.isGenerator(module, decomposition));
        CHECK(!four.isGenerator(module, decomposition));
}

TEST(Integer, ModAddInFp)
{
	AAL::Integer i("8"), j("13"), p("17"),k, notprime("18");
	CHECK(k.ModAddInFp(i,j,p).ToString() == "4");

        try
        {
                k.ModAddInFp(i,j,notprime);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }
}

TEST(Integer, SubInFp)
{
	AAL::Integer i("8"), j("13"), p("17"),k, notprime("18");
	CHECK(k.SubInFp(i,j,p).ToString() == "12");

        try
        {
                k.SubInFp(i,j,notprime);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }
}

TEST(Integer, MulInFp)
{
	AAL::Integer i("2"), j("13"), p("17"),k, notprime("18");
	CHECK(k.MulInFp(i,j,p).ToString() == "9");

        try
        {
                k.MulInFp(i,j,notprime);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }
}

TEST(Integer, DivInFp)
{
	AAL::Integer i("4"), j("3"), p("17"),k, notprime("18"), rem;
	CHECK(k.DivInFp(i,j,p,&rem).ToString() == "7" && rem.ToString() == "1");

        try
        {
                k.DivInFp(i,j,notprime,&rem);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }
}

TEST(Integer, PowInFp)
{
	AAL::Integer i("5"), j("6"), p("17"),k, notprime("18");
	CHECK(k.PowInFp(i,j,p).ToString() == "2");

        try
        {
                k.PowInFp(i,j,notprime);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }
}

TEST(Integer, InMulGroupInFp)
{
	AAL::Integer i("5"), p("17"),notprime("18");
	CHECK(i.InMulGroupInFp(p));

        try
        {
                i.InMulGroupInFp(notprime);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }
}

TEST(Integer,  InverseInFp)
{
	AAL::Integer i("5"), k, p("17"),notprime("18");
	CHECK(k.InverseInFp(i, p).ToString() == "7" );

        try
        {
                k.InverseInFp(i, notprime);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }
}

