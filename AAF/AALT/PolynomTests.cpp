/*
    MPEI Algebraic Abstractions Library,
    2007-2011,
    Moscow Power Engineering Institute

        This file contains tests of the following classes:

*/
#include <iostream>
#include "./CppUnitLite/TestHarness.h"
#include "./AAF/AAL/Polynom.h"
#include "./AAF/AAL/Matrix.h"
#include "./AAF/AAL/Integer.h"
#include "./AAF/AAL/DecompositionManager.h"
#include "./AAF/AAL/FactorizationAlgorithms.h"
#include <set>
using namespace AAL;

/*
	Конструкторы класса Polynom
*/

TEST(Polynom, EmptyConstructor)
{
	Polynom p;
	CHECK(p.isZero());
}

TEST(Polynom, CopyConstructor)
{
	Polynom p("111111111110001010010101010010101010101010101011001011111111111"), pp(p);
	CHECK(p==pp);
}

TEST(Polynom, StringConstructor)
{
	Polynom p1("0"), p2(""), p3("101001");

	CHECK(p1.isZero());
	CHECK(p2.isZero());
	CHECK(p3.getDigit(0) == 37);
}
TEST(Polynom, DegreeStringConstructor)
{
        const std::string polynomDegrees = "0 1 3 6";
 	Polynom p1(polynomDegrees,true);
        Polynom p2("1101001");
	CHECK(p1 == p2);
}
/*
	Операции мультипликативной группы и поля
*/
TEST(Polynom, Inverse)
{
	Polynom a("10110001110101111101"), inv("10110111110000000001"), mod("100000000000000100001");
	CHECK(inv == a.Inverse(a,mod));

	/* Тесты М. Волокитина */
	Polynom a2("0001100001101000100101101001111011110000111000011111001100000111001000101100100010110101101011111111");
	Polynom mod2("11000001101111001");
	Polynom inv2("1001001011001001");
	CHECK(inv2 == a2.Inverse(a2,mod2));

	Polynom a3("0010001000111111011100111001111010001100011010010110001101000001100101011101001011010111100110001111");
	Polynom mod3("11101001110101");
	Polynom inv3("100001010111");
	CHECK(inv3 == a3.Inverse(a3,mod3));

	Polynom a8("000100111101000000101011110111011101101111101010101000101111001100111010010001011010010111101010001");
	Polynom mod8("11110000011111");
	Polynom inv8("011111101101");
	CHECK(inv8 == a8.Inverse(a8,mod8));

	Polynom a10("1010100010011011011001100110001100100010000111110011001111011100010000001111001010100111101001111");
	Polynom mod10("1000011100101001");
	Polynom inv10("00000001001001");
	CHECK(inv10 == a10.Inverse(a10,mod10));

	Polynom a24("11010001100001111110110000010100110000100001011010011100110100100000000100101111100100010011011111");
	Polynom mod24("111111010001111");
	Polynom inv24("11001101110101");
	CHECK(inv24 == a24.Inverse(a24,mod24));

	Polynom a25("1001110100111101000101110110100011111100001010000100000001001110000011000101010110110000111111000011");
	Polynom mod25("11110010010001101");
	Polynom inv25("011111100111101");
	CHECK(inv25 == a25.Inverse(a25,mod25));

	Polynom a37("0000001010110001011100011000001000100100010000011111011111101001100000101001111010010101001101011111");
	Polynom mod37("10110111100101011");
	Polynom inv37("011001001001011");
	CHECK(inv37 == a37.Inverse(a37,mod37));

	Polynom a40("1110010110100011010100000010010111000100011110111011000110101011100010010011001110110110111110110011");
	Polynom mod40("11010000101");
	Polynom inv40("010000001");
	CHECK(inv40 == a40.Inverse(a40,mod40));

	/* Тесты М. Волокитина */
}

TEST(Polynom, Trace)
{
        Polynom a("00001"), mod("101001");

        CHECK(a.Trace(mod).isZero());
}
/* Тесты Чернышевой*/
TEST (Polynom, getPowersOfPolynom)
{
  Polynom a("00001"), b("101001");

  std::set<uint> setA, setB;
  std::set<uint> setAA, setBB;
  setAA.insert(4);
  setBB.insert(0);
  setBB.insert(2);
  setBB.insert(5);
  setA = a.getPowersOfPolynom();
  setB = b.getPowersOfPolynom();

  bool flag = false;
  std::set<uint>::iterator j = setAA.begin();
  for (std::set<uint>::iterator i = setA.begin(); i != setA.end(); ++i)
  {
    if (*i != *j)
    {
      flag = false;
      break;
    }
    else
      flag = true;
    j++;
  }
  CHECK(flag == true);

  j = setBB.begin();
  for (std::set<uint>::iterator i = setB.begin(); i != setB.end(); ++i)
  {
    if (*i != *j)
    {
      flag = false;
      break;
    }
    else
      flag = true;
    j++;
  }
  CHECK(flag == true);
}

TEST(Polynom, getPowersString)
{
  Polynom a("00001"), b("101001");

  std::string sA, sB;
  sA = a.ToString("00001");
  sB = b.ToString("101001");
  CHECK(sA == "4");
  CHECK(sB == "0 2 5");
}


TEST(Polynom, ONB1)
{
  Polynom p;
  CHECK(p.ONB1Test(1));
  CHECK(p.ONB1Test(2));
  CHECK(p.ONB1Test(4));
  CHECK(p.ONB1Test(10));
  CHECK(p.ONB1Test(12));
  CHECK(p.ONB1Test(18));
  CHECK(p.ONB1Test(652));

  CHECK(!p.ONB1Test(3));
  CHECK(!p.ONB1Test(5));
  CHECK(!p.ONB1Test(6));
  CHECK(!p.ONB1Test(9));
  CHECK(!p.ONB1Test(14));
  CHECK(!p.ONB1Test(726));
}

TEST(Polynom, ONB2)
{
  Polynom p;
  CHECK(p.ONB2Test(2));
  CHECK(p.ONB2Test(5));
  CHECK(p.ONB2Test(6));
  CHECK(p.ONB2Test(9));
  CHECK(p.ONB2Test(14));
  CHECK(p.ONB2Test(18));
  CHECK(p.ONB2Test(26));
  CHECK(p.ONB2Test(785));

  CHECK(!p.ONB2Test(3));
  CHECK(!p.ONB2Test(4));
  CHECK(!p.ONB2Test(23));
  CHECK(!p.ONB2Test(791));
}

TEST(Polynom, ONB3)
{
  Polynom p;
  CHECK(p.ONB3Test(3));
  CHECK(p.ONB3Test(11));
  CHECK(p.ONB3Test(23));
  CHECK(p.ONB3Test(35));
  CHECK(p.ONB3Test(39));
  CHECK(p.ONB3Test(743));

  CHECK(!p.ONB3Test(2));
  CHECK(!p.ONB3Test(4));
  CHECK(!p.ONB3Test(5));
  CHECK(!p.ONB3Test(12));
  CHECK(!p.ONB3Test(29));
  CHECK(!p.ONB3Test(749));
}


TEST(Polynom, GNB)
{
  Polynom p;
  CHECK(p.GNBTest(4, 3));
  CHECK(p.GNBTest(13, 4));
}


TEST(Polynom, CreateONB)
{
  Polynom b1, b1res("11111111111");
  Matrix A1(Matrix::ON_LINE, 10, 10, 0);
  bool is;
  is = b1.GenerateONB1(10, b1, A1);
  CHECK(is);
  std::string A1res = "{0,5}{1,5}{1,6}{2,3}{2,7}{3,2}{3,8}{4,7}{4,9}{5,0}{5,1}{6,1}{6,8}{7,2}{7,4}{8,3}{8,6}{9,4}{9,9}";
  CHECK(b1 == b1res);
  CHECK(A1res == A1.ToStringNotNullBits());

  Polynom b2, b2res("110000001100111");
  Matrix A2(Matrix::ON_LINE, 14, 14, 0); 
  is = b2.GenerateONB2(14, b2, A2);
  CHECK(is);
  std::string A2res = "{0,1}{1,0}{1,5}{2,5}{2,8}{3,10}{3,12}{4,7}{4,13}{5,1}{5,2}{6,8}{6,12}{7,4}{7,11}{8,2}{8,6}{9,10}{9,11}{10,3}{10,9}{11,7}{11,9}{12,3}{12,6}{13,4}{13,13}";
  CHECK(b2 == b2res);
  CHECK(A2res == A2.ToStringNotNullBits());

  Polynom b3, b3res("101110001011");
  Matrix A3(Matrix::ON_LINE, 11, 11, 0);
  is = b3.GenerateONB3(11, b3, A3);
  CHECK(is);
  std::string A3res = "{0,1}{1,0}{1,8}{2,6}{2,8}{3,4}{3,5}{4,3}{4,9}{5,3}{5,7}{6,2}{6,9}{7,5}{7,10}{8,1}{8,2}{9,4}{9,6}{10,7}{10,10}";
  std::string s = A3.ToStringNotNullBits();
  CHECK(b3 == b3res);
  CHECK(A3res == A3.ToStringNotNullBits());
}
//--------------------------------------------------------------------------------------
TEST(Polynom, elementOrder)
{
  Polynom u;
  Polynom mod("1001001"), a("11");
  AAL::Integer ord(63);
  FactorizationAlgorithms w(ord);
  bool r;
  std::vector<DecompositionMember> vector = w.ProbingDivisionAlgorithmDecomposition();
  AAL::Integer t = u.elementOrder(mod, a,vector,ord);
  CHECK(t == 63);
}
//--------------------------------------------------------------------------------------
TEST(Polynom, isGenerator)
{
  Polynom u;
  Polynom mod("1001001"), a("11");
  AAL::Integer ord(63);
  FactorizationAlgorithms w(ord);
  bool r;
  std::vector<DecompositionMember> vector = w.ProbingDivisionAlgorithmDecomposition();
  r = u.isGenerator(mod, a,vector,ord+1);
  CHECK(r == true);
}

//--------------------------------------------------------------------------------------
/*
	Методы акцепторы
*/
TEST(Polynom, isNormal)
{
        Polynom p0("1011"), p1("111011"), p2("100011");

        CHECK(p0.isNormal());
	CHECK(p1.isNormal());
        CHECK(!p2.isNormal());
}

TEST(Polynom, isIrreducible)
{
        Polynom p0("1011"), p1("111011"), p2("100011");
        Polynom p3("11"), p4("01");

        CHECK(p0.isIrreducible());
        CHECK(p1.isIrreducible());
        CHECK(!p2.isIrreducible());
        CHECK(p3.isIrreducible());
        CHECK(p4.isIrreducible());
        CHECK(1 != 0);
}
TEST(Polynom, isPrimitivity)
{
  Polynom p0("111"), p1("1011"), p2("10011"), p3("1000011"), p4("10000011");
  Polynom p5("101001"), p6("1000000011"), p7("10000000000000000000000000011");
  Polynom p8("10011001");
  CHECK(p0.isPrimitivity());
  CHECK(p1.isPrimitivity());
  CHECK(p2.isPrimitivity());
  CHECK(p3.isPrimitivity());
  CHECK(p4.isPrimitivity());
  CHECK(p5.isPrimitivity());
  CHECK(!p6.isPrimitivity());
  CHECK(!p7.isPrimitivity());
  CHECK(!p8.isPrimitivity());
}

/*
	Унарные операторы
*/
TEST(Polynom, unaryOperatorOnesComplement)
{
	Polynom p("1101");
	Polynom pp("0010");

	CHECK(~p == pp);
}

TEST(Polynom, OnesComplement)
{
	Polynom p("110011");
	Polynom pp("001100");

	CHECK(p.OnesComplement() == pp);
}

TEST(Polynom, operatorEqual)
{
	Polynom p1("110100101010101010101010101011001011111111111111111111");
	Polynom p2("11111111111111111111111111111111111111111111111111111111111111110000101010100101");
	Polynom p3("111110111111111111111111111111111111111100000000000000000000000000000000011111111111111111");
	Polynom pp1, pp2, pp3, pp4;

	pp1 = p1;
	pp2 = pp3 = p2;

	p2 = p1;
	p3 = pp4;

	CHECK(pp1 == p1 && !p1.isZero() && p1.ToString() == "110100101010101010101010101011001011111111111111111111");
	CHECK(pp2 == pp3 && !pp3.isZero() && pp2.ToString() == "11111111111111111111111111111111111111111111111111111111111111110000101010100101");
	CHECK(p2 == p1 && p2.ToString() == "110100101010101010101010101011001011111111111111111111");
	CHECK(p3.isZero());
}

/*
	Операции сравнения
*/
TEST(Polynom, Compare)
{
	Polynom p1("1111111111111111111111111000111"), p2("1111"), comp("0000111111111111111111111000111");
	CHECK(p1.Compare(p2) ==  comp);
}

TEST(Polynom, Equal)
{
	Polynom i,j;
	CHECK(i == j);

	Polynom k("111111111111111111111111111000000000000000011111"), l("111111");
	CHECK(!(k == l) && !(k == j));

	Polynom m("111000111"), n("111000111");
	CHECK(m == n);

	Polynom *o = new Polynom("11111"), *p = o;
	CHECK(*o == *p);
	delete o;
}

TEST(Polynom, Smaller)
{
	Polynom i("1111111111111111111111111111"), j("11111");
	CHECK(j < i);

	AAL::Integer k,l("");
	CHECK(!(l < k) && l == k);
}

/*
	Логические операции
*/
TEST(Polynom, Xor)
{
	Polynom i("100000101010101010100001111100011111111111111111111111111100000000000000000000000000000000");
	Polynom j("001010101111111110100101010100101010101010101001010010100100000000000000001111111111111111");
	Polynom res;
	Polynom iXORj("101010000101010100000100101000110101010101010110101101011000000000000000001111111111111111");
	
	res.Xor(i, j);
	CHECK(res == iXORj);

	res.Xor(i,i);
	CHECK(res.isZero());

	res.Xor(j, iXORj);
	CHECK(res == i);
}

TEST(Polynom, Or)
{
	Polynom i("100000101010101010100001111100011111111111111111111111111100000000000000000000000000000000");
	Polynom j("001010101111111110100101010100101010101010101001010010100100000000000000001111111111111111");
	Polynom k;
	Polynom res;
	Polynom iORj("101010101111111110100101111100111111111111111111111111111100000000000000001111111111111111");
	
	res.Or(i, j);
	CHECK(res == iORj);

	res.Or(i, k);
	CHECK(res == i);

	res.Or(i,i);
	CHECK(res == i);
}

TEST(Polynom, And)
{
	Polynom i("100000101010101010100001111100011111111111111111111111111100000000000000000000000000000000");
	Polynom ii("100000101010101010100001111100011111111111111111111111111100000000000000000000000000000000");
	Polynom j("001010101111111110100101010100101010101010101001010010100100000000000000001111111111111111");
	Polynom k;
	Polynom res;
	Polynom iANDj("000000101010101010100001010100001010101010101001010010100100000000000000000000000000000000");
	
	res.And(i, j);
	CHECK(res == iANDj);

	res.And(i, k);
	CHECK(res.isZero());

	res.And(i,i);
	CHECK(res == i);
}

TEST(Polynom, Not)
{
	Polynom i("100000101010101010100001111100011111111111111111111111111100000000000000000000000000000000");
	Polynom k;
	Polynom res;
	Polynom NOTi("0111110101010101010111100000111");

	res.Not(i);
	CHECK(res == NOTi);

	CHECK((!k).isOne() && k.isZero());
}

/*
	Операции побитового сдвига
*/
TEST(Polynom, SHL)
{
	Polynom i("100000001010101001010101010001010100010100101111111111111111111111111100000111111111111111111111000001111111111111000001111111111111");
	Polynom j("000000000000000000000000000000000000000000000100000001010101001010101010001010100010100101111111111111111111111111100000111111111111111111111000001111111111111000001111111111111");
	Polynom k;

	k<<=100;
	CHECK((i<<45) == j && k.isZero());
}

TEST(Polynom, SHR)
{
	Polynom i("100000001010101001010101010001010100010100101111111111111111111111111100000111111111111111111111000001111111111111000001111111111111");
	Polynom j("10100101111111111111111111111111100000111111111111111111111000001111111111111000001111111111111");
	Polynom k;
        Polynom m("00000001");

	k>>=10001;
        m>>=10;
	CHECK((i>>37) == j && k.isZero() && m.isZero());
}

/*
	Операция умножения
*/
TEST(Polynom, Mul)
{
	Polynom i("100000001010101001010101010001010100010100101111111111111111111111111100000111111111111111111111000001111111111111000001111111111111");
	Polynom j("10100101111111111111111111111111100000111111111111111111111000001111111111111000001111111111111");
	Polynom k ("1010010101111011111101011000110101001110110110111110100000010000100101011110110111000101101100101111111111001010111110011010011001010101010101010101010101000000000001010101010101010101010101000000000001010101010101010101010101");

	CHECK(k == i.Mul(i,j));

	/* Тесты М. Волокитина */
	Polynom i2("0110010110110101110111010000100100001011101101011111100010010011100111011101011001101111111000001111");
	Polynom j2("0001110111101010010100000110100000011100000001111001110110111001010101001000010010000111001001111");
	Polynom k2("0000100101000010110100101010110000110000110111001101010111100100010010010011001101000000111010110010001010011111100100110010111100110010010101100101000000100110011111011000001110111101001110010101");
	CHECK(k2==i2.Mul(i2,j2));

	Polynom i3("100100110001001100000100110111100010101100000010101100101000101101010001011100011001101110111101");
	Polynom j3("11010110011011101111001111010101010011011100100000011011110010100011000111100110001101111111110101");
	Polynom k3("1100111001001110011101010010001100011100011010011010100000111100001010100000010101100001100011000101111000001001011100101011000001111100101001011100011110010100011101000000110111100001111111001");
	CHECK(k3==i3.Mul(i3,j3));

	Polynom i4("010111001000000000001001000010110100000111010000111101111111110000010001110010011101010101001011001");
	Polynom j4("0110100101011100000100100000011101111110010000010101100000110101001111101000110000000100111001001");
	Polynom k4("001111000011001111110000101000011011010010100001110011000011100010011101110000010011001110001001011011101001101001101100101111100111000010111011010010001011101000010000001011001001101001101010001");
	CHECK(k4==i4.Mul(i4,j4));

	Polynom i5("11000110110110011101101100100100111011000111111010110000010111110111001101100010010110000110011");
	Polynom j5("1000100111100111111111010000010010011010111001101110111101011000101001000100000101011000101000111001");
	Polynom k5("11001011101010011101000101110010111010111101000010011111110010001110011011001110100100101001001010010010000000000111100110111100101000100101111110011001001001110111110111111000000111011011111011");
	CHECK(k5==i5.Mul(i5,j5));

	Polynom i6("101100110100011000100000011100101111001000111111010110000010111000010100110110000010000100111000001");
	Polynom j6("110001011110110111110100011011101100110110110000011011101000011100011100110101011101111000100111111");
	Polynom k6("11101110110100001010010011010000010100110001001010111110000100110010000001101110011101001011010110101101000001001110100110011010000110111000111101100110001111000010100000000011011011110011001111111");
	CHECK(k6==i6.Mul(i6,j6));

	Polynom i7("0011010111111000010111100010010111001001111011001100011100111001110011110001100010000101110010100011");
	Polynom j7("0001001010010010111000101011011000010110101011110110011101001001110001010011101101001011100101101111");
	Polynom k7("0000011001011011010110001001101001110110101001110000000000110000100011100111111011010011001101011110111010011110100011101001001001111001011101111011011001100011010000100001001000011011010010111010001");
	CHECK(k7==i7.Mul(i7,j7));

	Polynom i8("0011000101111110011101010111110100000010011111011010100001010000010011110000000100010001001111110011");
	Polynom j8("0000011011000001110000111110010110001101101001001111010111100101010111111101010010101000010001111");
	Polynom k8("0000000101100111100000001000111100111011111111100001100111110111011000001100100001100011000111101101001101111110000110100110100001001100011100000000011011010001010010010111001111101110110111000001");
	CHECK(k8==i8.Mul(i8,j8));

	Polynom i9("0111100100001011001101001100001100010001010111011101001111101111100111001100111111010100101110100101");
	Polynom j9("01100000011101111111100111011000000011110011101011011011010100111100010010111000000101111111011");
	Polynom k9("00100010111010000011110011000001000000110100100011010111000001000101000110001001100101111000000110101010001010000010111010101110110001101101101000110010110010101011000100010010101011001111110111");
	CHECK(k9==i9.Mul(i9,j9));

	Polynom i10("0100010101111000001011111100011100011001110010000100001101010000111110001110010010000111110100100111");
	Polynom j10("1011110100111000011010011001010110010010000100010011101111000011100111000011110100100000111010001101");
	Polynom k10("0101101001100010000000111110111101011010110101101000001010000100100111110111001101101111100110110011111100011100100111001000111100011000010110000111100011100100011100111001000100011010001100100000011");
	CHECK(k10==i10.Mul(i10,j10));

	/* Тесты М. Волокитина */
}

/*
	Операция деление
*/
TEST(Polynom, Div)
{
	Polynom i("001010101111111110100101010100101010101010101001010010100100000000000000001111111111111111");
	Polynom j("101001011111111111111111111111111000001111111111111111111110000011111111");
	Polynom k ("0000010000100000001");
	Polynom r, r1("0010111111111001000011000010110101010110101010011010101010111111");
	
	CHECK((k == i.Div(i,j,&r)) && (r == r1));

	Polynom i1("1010100100111100001001");
	Polynom j1("101001");
	Polynom k1 ("11101101000100001");
	Polynom r2, r3("01111");

	CHECK((k1 == i1.Div(i1,j1,&r2)) && (r2 == r3));

	Polynom i2("001");
	Polynom j2("111");
	Polynom k2 ("1");
	Polynom r4, r5("11");

	CHECK((k2 == i2.Div(i2,j2,&r4)) && (r4 == r5));	

	/* Тесты М. Волокитина */
	Polynom i6("1100011010000011111000111000101101101000001101100100100011001001110000011111010000000001010000111001");
	Polynom j6("1001111101011101001110011000000110010011000010001110110001010001100110111110010100100001001100111011");
	Polynom k6("1");
	Polynom q6,p6("010110011101111011011010000010101111101100111110101001001001100001011010000100010010000001110000001");
	CHECK((k6==i6.Div(i6,j6,&q6)) && (q6 == p6));

	Polynom i7("0000001111100000101000011111110001101100001011010011010010000110010010001011111101000010110101111101");
	Polynom j7("000010010101001101010111101101101001001000100111101100100000010101110001011100101100111101001000011");
	Polynom k7("11");
	Polynom q7,p7("00001110000110100101110110010001101101110001100101011111100000011000000101110100111010100011101110");
	CHECK((k7==i7.Div(i7,j7,&q7)) && (q7 == p7));

	Polynom i8("010011100001010101000001010001101011110010000110101100101001100001010111111100011110110011110110001");
	Polynom j8("0111110010011100111000110101111010010001000100010010110100001011110001000110000101110110111000011111");
	Polynom k8("0");
	Polynom q8,p8("010011100001010101000001010001101011110010000110101100101001100001010111111100011110110011110110001");
	CHECK((k8==i8.Div(i8,j8,&q8)) && (q8 == p8));

	Polynom i9("10100101000100010001011100101101101001000111111100010001001001001101101011101000010001110101100111");
	Polynom j9("0000111001010011001000100111010001011010010011100111111100000010111101111001010111100110000010111");
	Polynom k9("01");
	Polynom q9,p9("1010001000111000100001100001011110001001010110000010111010100101101000010010001010110100010111");
	CHECK((k9==i9.Div(i9,j9,&q9)) && (q9 == p9));

	Polynom i10("1110111011111101000001010100000000001110001011110011010000101001101010010101111110100100010000100011");
	Polynom j10("010001100110000110101001011100110000101100101110100101001001110001110000110111101110000101100000101");
	Polynom k10("11");
	Polynom q10,p10("10001011101011000111100010001010100000001001011011101010111110111110000111101110001101011001001011");
	CHECK((k10==i10.Div(i10,j10,&q10)) && (q10 == p10));

	/* Тесты М. Волокитина */
}

/*
	Операция приведения по модулю
*/
TEST(Polynom, Mod)
{
	Polynom i("001010101111111110100101010100101010101010101001010010100100000000000000001111111111111111");
	Polynom j("101001011111111111111111111111111000001111111111111111111110000011111111");
	Polynom r, r1("0010111111111001000011000010110101010110101010011010101010111111");
	
	CHECK(r.Mod(i,j) == r1);

	/* Тесты М. Волокитина */
	Polynom i2("1001000111100011110100010100101100011001000011111110100111101111111101110010011101011101000001110111");
	Polynom j2("1101010110110000001000010111011000010001010010001110110111000001100000100001000111000100111110010011");
	Polynom q2,p2("01000100010100111111000000111101000010000100011100000100001011100111010100110110100110011111111001");
	CHECK(q2.Mod(i2,j2) == p2);

	Polynom i3("0111110110001010100000100000001111011010010100001000100001001011011100101110100100011100101001111");
	Polynom j3("1111000111110111001010001100110110010110111010010000110001010001011000001110100100000110011101100011");
	Polynom q3,p3("0111110110001010100000100000001111011010010100001000100001001011011100101110100100011100101001111");
	CHECK(q3.Mod(i3,j3) == p3);

	Polynom i4("10000011001010001001101110110110001100111101111100111100011100110000110011110000011011010111001101");
	Polynom j4("011111011010001100011111011010110001000110110000101111101011010011110101110100111111101111001110101");
	Polynom q4,p4("10000011001010001001101110110110001100111101111100111100011100110000110011110000011011010111001101");
	CHECK(q4.Mod(i4,j4) == p4);

	Polynom i5("000110011011111011100111100010000000110010110001111110000000101101011001011011100011111111100100011");
	Polynom j5("0011111110100110100000110010001101011111001110100011100110010111010000110001101000000111001001010011");
	Polynom q5,p5("000110011011111011100111100010000000110010110001111110000000101101011001011011100011111111100100011");
	CHECK(q5.Mod(i5,j5) == p5);

	Polynom i6("1110010110100111011111111010010111001111100111101101110011000010111010101100100010010010000110011111");
	Polynom j6("0101010100001101100110111001111010110011100010011101011001001100111011111100000110011110000111");
	Polynom q6,p6("10010001110110011010110011101001100010010110110011111100001110001101110010101110111101101011");
	CHECK(q6.Mod(i6,j6) == p6);

	Polynom i7("011101011101010011101100110110010110110000110101011111100111110111010010011000100111010010100001");
	Polynom j7("10000001110110000001001110100110110001110010111110100111000110001100111010011001010010010001011111");
	Polynom q7,p7("011101011101010011101100110110010110110000110101011111100111110111010010011000100111010010100001");
	CHECK(q7.Mod(i7,j7) == p7);

	Polynom i8("0100010110011011110010010110110000110101011001001011010101000101101010010100010110101001000001110001");
	Polynom j8("1011111100011110110111000101001111100001010101000001101111000110111101101000110001111111100100101011");
	Polynom q8,p8("111110101000010100010101001111111101010000110000101011101000001101011111110010011101011010010101101");
	CHECK(q8.Mod(i8,j8) == p8);

	Polynom i9("101111001101000001111101111001111100111110101001101110110111111010010110101000011011101111010011101");
	Polynom j9("010101000100011000101011010001100110111110000001000101111101100110000000000101101111011001010110011");
	Polynom q9,p9("11101000100101100101011010100001101000000010100010101100101001110001011010110111010011011000010111");
	CHECK(q9.Mod(i9,j9) == p9);

	Polynom i10("0110101110110010010101110011101001111101110100111010000110110111110010100000110010001100100010110001");
	Polynom j10("1110010101001001100111001101110010001011010011111110010000001110000110010100001011010010000001000001");
	Polynom q10,p10("100011101111101111001011111001101111011010011100010001011011100111010011010011100101111010001111");
	CHECK(q10.Mod(i10,j10) == p10);

	/* Тесты М. Волокитина */
}

/*
	Операция возведение в степень
*/
TEST(Polynom, Pow)
{
	Polynom a("1111"),b("1010101");
	AAL::Integer n(2);
	CHECK(b == a.Pow(a,n));
}

TEST(Polynom, ModPow)
{
	Polynom a("110101001011111111"),b("1"),	mod("101001"),c;
	AAL::Integer n(31);
	CHECK(b == c.ModPow(a,n,mod));

	Polynom a1("01"),
	b1("000000000000000001"),
	mod1("100000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"),
	c1;
	AAL::Integer n1(17);
	CHECK(b1 == c1.ModPow(a1,n1,mod1));
	CHECK(c1.ToString() == "000000000000000001");


	/* Тесты М. Волокитина */
	Polynom a3("0110010111011011111111001011010100100010111111001011101100000111111011011100111000011001110100011001");
	Polynom mod3("10111100000101");
	Polynom k3;
	Polynom b3("110111010011");
	AAL::Integer n3(6);
	CHECK(b3 == k3.ModPow(a3,n3,mod3));

	Polynom a23("0001101010010010000011111101111101001100100110100111110101010100001100110010010100101101010101111111");
	Polynom mod23("11111101000011");
	Polynom k23;
	Polynom b23("0100110100111");
	AAL::Integer n23(52);
	CHECK(b23 == k23.ModPow(a23,n23,mod23));

	Polynom a24("0011101100001010011000011010101011011111010011101110000111110001100011011111010010011000111010000011");
	Polynom mod24("11110110001000011");
	Polynom k24;
	Polynom b24("0111010111010001");
	AAL::Integer n24(56);
	CHECK(b24 == k24.ModPow(a24,n24,mod24));

	Polynom a26("1101000001011110011001000101000011101110110001010111111011110000100001100110010101111011110111101101");
	Polynom mod26("10110110110101");
	Polynom k26;
	Polynom b26("000100000101");
	AAL::Integer n26(25);
	CHECK(b26 == k26.ModPow(a26,n26,mod26));

	Polynom a34("110100001011000010010011011111001110110011000001001001111011001000001011011100010101010111010001101");
	Polynom mod34("11101011011111");
	Polynom k34;
	Polynom b34("110101110101");
	AAL::Integer n34(83);
	CHECK(b34 == k34.ModPow(a34,n34,mod34));

	Polynom a37("100101000000011101001110111111110010111110011001011010110001000111111110010111110101001110111001");
	Polynom mod37("10101011001010101");
	Polynom k37;
	Polynom b37("0100101011111");
	AAL::Integer n37(1);
	CHECK(b37 == k37.ModPow(a37,n37,mod37));

	/* Тесты М. Волокитина */
}

/*
	Алгоритмы Евклида
*/
TEST(Polynom, Euclid)
{
	Polynom a("101001"), b("11001"), e;
	CHECK(e.Euclid(a, b).isOne());

        a.setZero();
        b.setZero();
        try
        {
                e.Euclid(a, b);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }
}

TEST(Polynom, BinaryGCD)
{
        Polynom a("101001"), b("11001"), res;
	CHECK(res.BinaryGCD(a, b).isOne());
}

TEST(Polynom, ExEuclid)
{
        Polynom a("101001"), b("11001"), x, y, c("0111"), d("10111"), e;
	CHECK(e.ExEuclid(a, b, x, y).isOne() && x==c && y==d);
}

/*
	Генерация многочленов
*/
TEST(Polynom, GenerateIrreducible)
{
	Polynom p0, p1, p2;
  p0.GenerateIrreducible(3, 3, 5);
  p1.GenerateIrreducible(5, 10, 10);
  p2.GenerateIrreducible(3, 5, 163);
	CHECK(p0.isIrreducible());
  CHECK(p1.isIrreducible());
}

TEST(Polynom, GenerateIrreducibleTrinomial)
{
  Polynom p0, p1, p2;
  p0.GenerateIrreducibleTrinomial(10);
  p1.GenerateIrreducibleTrinomial(5);
  p2.GenerateIrreducibleTrinomial(2);
  CHECK(p0.isIrreducible());
  CHECK(p1.isIrreducible());
  CHECK(p2.isIrreducible());
}

TEST(Polynom, GenerateIrreduciblePrimitivity)
{
  Polynom p0, p1;
  p0.GenerateIrreduciblePrimitivity(3, 3, 5);
  p1.GenerateIrreduciblePrimitivity(5, 10, 10);
  CHECK(p0.isIrreducible());
  CHECK(p1.isIrreducible());
  CHECK(p0.isPrimitivity());
  CHECK(p1.isPrimitivity());
}

TEST(Polynom, GenerateNormal)
{
	Polynom p0, p1;
  p0.GenerateNormal(3, 5, 5);
  p1.GenerateNormal(5, 10, 10);
	CHECK(p0.isNormal());
  CHECK(p1.isNormal());
}

TEST(Polynom, WrappingGenerate)
{
        Polynom forwrap("101"), badforwrap("101001010101001010101"), module("100000000101"), result;
	CHECK((result.WrappingGenerate(forwrap, module) & forwrap) == forwrap);

        try
        {
                result.WrappingGenerate(badforwrap, module);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }
}

TEST(Polynom, AddInGF2_n)
{
        Polynom a("001"),b("1"), c, mod("1101"),irrmod("11011");

        CHECK(c.AddInGF2_n(a,b,mod).ToString() == "101")
        try
        {
                c.AddInGF2_n(a,b,irrmod);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }
}

TEST(Polynom, MulGF2_n)
{
        Polynom a("001"),b("1"), c, mod("1101"),irrmod("11011");

        CHECK(c.MulGF2_n(a,b,mod).ToString() == "001")
        try
        {
                c.MulGF2_n(a,b,irrmod);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }

}

TEST(Polynom, DivInGF2_n)
{
        Polynom a("001"),b("01"), c, rem, mod("1101"),irrmod("11011");

        CHECK(c.DivInGF2_n(a,b,mod, &rem).ToString() == "01" && rem.isZero())
        try
        {
                c.DivInGF2_n(a,b,irrmod, &rem);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }

}

TEST(Polynom, PowGF2_n)
{
	Polynom a("110101001011111111"),b("1"),	mod("101001"),c, irrmod("11011");
	AAL::Integer n(31);

        CHECK(c.PowGF2_n(a,n,mod).isOne())
        try
        {
                c.PowGF2_n(a,n,irrmod);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }

}

TEST(Polynom, InverseGF2_n)
{
        Polynom a("10110001110101111101"),  c, mod("100000000000000100001"), irrmod("11011");

        CHECK(c.InverseGF2_n(a,mod).ToString() == "10110111110000000001")
        try
        {
                c.InverseGF2_n(a,irrmod);
                CHECK(false);
        }
        catch(Exception *E)
        {
                CHECK(true);
        }

}
